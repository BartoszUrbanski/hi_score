#!/bin/bash

## See style-guide
## https://google.github.io/styleguide/shell.xml#Function_Names
## http://www.davidpashley.com/articles/writing-robust-shell-scripts.html

## Exit when encountering undeclared variables
## The -e check ( exit when encountering a non-zero exit status )
## As we do our own checking 
set -u;

## == BEGIN Layout variables ===============================================
  _app_name=$( basename $0 );
  _orig_dir=$( pwd );
  echo "start ${_app_name}";
  echo "  > layout vars";

    # app path and name
    _app_link=$( readlink -f -- "${0}" );
    _bin_dir=$( cd "${_app_link%/*}" && echo "${PWD}" );

    # npm modules paths
    _npm_dir=$( dirname "${_bin_dir}" );
    _mod_dir="${_npm_dir}/node_modules";
    _mod_dir_bin="${_mod_dir}/.bin";
    _ugjs_exe="${_mod_dir_bin}/uglifyjs";
    _ugcss_exe="${_mod_dir_bin}/uglifycss";

    _top_log_name="${_app_name}.log";
    _top_log_file="${_npm_dir}/${_top_log_name}";

    # timestamps
    _start_date_=$(date "+%Y-%m-%d %H:%M:%S");
    _ext_date=$(date "+%Y%m%d_%H%M%S");

    # CLI switch varibles
    _dist_dir="${_npm_dir}/build/dist";
    _stage_dir="${_npm_dir}/build/stage";
    _prod_dir="${_npm_dir}/build/prod";  
    _tmplt_dir="${_npm_dir}/build/tmplt";
    _do_help=0;
    _dont_compress=0;
    _do_verbose=0;

    # temp dir 
    # See http://www.linuxsecurity.com/content/view/115462/81/#mozTocId440182
    _tmp_dir="${TMPDIR-/tmp}/$$.${_app_name}.${_ext_date}";
    ( umask 077 && mkdir "${_tmp_dir}" ) || {
      _do_verbose=1;
      _log_fn "## ! Could not create temporary directory";
      _abort_fn;
    }
  # echo "  < layout vars";
  ## == END Layout variables =================================================

## BEGIN function to echo to STDERR
_log_stderr_fn () { echo "$*" >&2; }
## END function to echo to STDERR

## BEGIN function to print usage
_show_use_fn () {
  _log_stderr_fn "
NAME : ${_app_name}

SYNOPSIS
  ${_app_name} [ options ] <buildfile1> <buildfile2> ...
";

  [ "${_do_verbose}" -lt 1 ] && _log_stderr_fn "
Employ the -v or --verbose switch to see more detailed help.
";

  [ "${_do_verbose}" -gt 0 ] && _log_stderr_fn "
DESCRIPTION
  ${_app_name} builds production-ready JavaScript files
  from sources specified in buildfiles.

  If the build file includes a javascript section, it creates
  a two javascript files in the same directory as the build file.
  The output files will have the same basename as the buildfile.
  Therefore, '${_app_name} gallery.${_app_name}' will output
  the files gallery-raw.js, gallery-min.js, and gallery-sp.js.

  Options may be employed to change the output location, and to turn
  compression off.

EXAMPLES
  (1) If the file gallery.${_app_name} looks like so:
      ==============
      source:js
      js/gallery.js
      ==============

  Then running buildify with this configuration:

      $ ${_app_name} ./gallery.${_app_name}

  will result in the following files:

      gallery-raw.js  # concatenated JS
      gallery-min.js  # uglified JS
      gallery-sp.js   # superpacked JS
      gallery-sp.diag # superpack diagnostics


  (2) If the file gallery.${_app_name} looks like so:
      ==============
      source:js
      js/gallery.js
      source:css
      css/gallery.css
      ==============

  Then running buildify with this configuration:

      ${_app_name} --nocompress ./gallery.${_app_name}

  will result in the following files:

      gallery-raw.js   # concatenated JS
      gallery-raw.css  # concatenated CSS


  (3) We can specify an alternate output directory.
      If the file gallery.${_app_name} looks like so:
      ==============
      source:js
      js/gallery.js
      source:css
      css/gallery.css
      ==============

  Then running buildify with this configuration:

      ${_app_name} -o /stage ./gallery.${_app_name}

  will result in the following files in the directory /stage:

      gallery-raw.js  # concatenated JS
      gallery-min.js  # uglified JS
      gallery-sp.js   # superpacked JS
      gallery-sp.diag # superpack diagnostics
      gallery-raw.css # concatenated CSS
      gallery-raw.css # minified CSS

ARGUMENTS
  buildfile1, buildfile2, ... (REQUIRED)
    Build files to process.
    Each build file lists source files to process. It may have up to
    two sections delineated by a source-type header.
    ${_app_name} EXPECTS ALL PATHS TO BE RELATIVE TO THE REFERENCING 
    CONFIRURATION FILE PATH.
       sourcetype:js   # for javascript files, and
       # ... js files here ...
       sourcetype:css # for css and source files
       # ... css files here .... (relative to buildfile path)

    Blank lines, comment lines, and trailing comments are ignored.

OPTIONS
  * -h | --help | --usage outputs this text and exit.

  * -o <path> |--outputdir=<path> (OPTIONAL)
    By default, ${_app_name} puts output files in the same directory
    as the build file.  Use this option to override the default location.
    <path> must be a writable directory.

  * -n | --nocompress (OPTIONAL)
    By default, ${_app_name} outputs minified named <name>-min.js
    and <name>-min.css.  This option disables creating and writing these
    files.

  * -v | --verbose (OPTIONAL)
    Be noisy when processing

REQUIRED PATCH
  Buildify requires a patch to optimize symbol compression. 
  If you have installed **hi\_score** this patch will already be applied.
  If you need to install the patch manually, this should work:
  
    \$ cd ../node_modules/
    \$ patch -p0 < ../patch/uglifyjs-2.4.10.patch

SEE ALSO
  * UglifyJS
  * UglifyCSS

AUTHOR and COPYRIGHT
  Michael S. Mikowski (c) 2008-2016
";

  exit 1;
}
## END function to print usage

## BEGIN function to log output
_log_fn () {
  local IFS='';
  _msg_str="$*";
  if [ -w "${_top_log_file}" ]; then
    echo "${_msg_str}" >> "${_top_log_file}";
  else
    _log_stderr_fn "${_msg_str}"
  fi

  if [ "${_do_verbose}" -gt 0 ]; then _log_stderr_fn "${_msg_str}"; fi
  return 0;
}
## END function to log output

## BEGIN function to clean up temp files
clean_tmp_files () {
  if [ -w "${_tmp_dir}" ]; then
    if echo "${_tmp_dir}" | grep -q "${_app_name}"; then
      _do_verbose=1;
      _log_fn "## Removing temporary directory ${_tmp_dir}";
      rm -rf "${_tmp_dir}";
    fi
  fi
}
## END function to clean up temp files

## BEGIN function to abort processing
_abort_fn () {
  _do_verbose=1;
  _log_fn '';
  _log_fn "## See ${_app_name} -hv for detailed usage.";
  _log_fn "## ! Processing ABORTED.";

  clean_tmp_files;
  # exit with error (bash shell standard)
  exit 1;
}
## END function to abort processing

## BEGIN MAIN
  ## BEGIN get options
  ## (see /usr/share/doc/util-linux/examples/getopt-parse.bash)
  _cli_str=$(getopt -o hnvd:s:p:t: \
    --long help,usage,nocompress,verbose,distdir:,stagedir:,proddir:,tmpltdir: \
      -n "${_app_name}" -- "$@")

  if [ $? != 0 ] ; then
		_do_verbose=1;
    _log_stderr_fn "Trouble processing command line.";
    _abort_fn; 
  fi

  # Note the quotes around $_cli_str: they are essential!
  eval set -- "${_cli_str}"

  while true; do
    case "$1" in
      -h|--help|--usage) _do_help=1;       shift ;;
      -n|--nocompress)   _dont_compress=1; shift ;;
      -v|--verbose)      _do_verbose=1;    shift ;;
      -d|--distdir)      _dist_dir="$2";   shift 2 ;;
      -s|--stagedir)     _stage_dir="$2";  shift 2 ;;
      -p|--proddir)      _prod_dir="$2";   shift 2 ;;
      -t|--tmpltdir)     _tmplt_dir="$2";  shift 2 ;;
      --) shift; break ;;
       *) _do_verbose=1;
          _log_stderr_fn "Trouble processing command line.";
          _abort_fn ;;
    esac
  done

  if [ ${_do_help} -gt 0 ]; then _show_use_fn; fi
  ## END get options (see /usr/share/doc/util-linux/examples/getopt-parse.bash)

  ## BEGIN set global log to start
  if ! echo -n > "${_top_log_file}"; then
    _do_verbose=1;
    _log_stderr_fn "Cannot create global log file '${_top_log_file}'";
    _abort_fn;
  fi
  # put header in log file
  _log_fn "## Global ${_app_name} log ${_start_date_} ##";
  ## END set global log to start

  ## BEGIN Find SuperPack
  _pack_exe="${_bin_dir}/superpack.pl";
  if [ -z "${_pack_exe}" ]; then
    _do_verbose=1;
    _log_fn "## ! Unable to locate the SuperPack compressor.";
    _log_fn " # See Michael Mikowski for original executable.";
    _abort_fn;
  fi
  if ( ! perl -cw "${_pack_exe}" >/dev/null 2>&1 ); then
    _do_verbose=1;
    _log_fn "## ! SuperPack is not valid perl.";
    _log_fn " # Please install perl-List-MoreUtils perl-File-Slurp ";
    _log_fn " # and perl-Getopt-Mixed.";
    _abort_fn;
  fi
  ## END Find SUPERPACK

  ## BEGIN Find UglifyJS
  if [ -z "${_ugjs_exe}" ]; then
    _do_verbose=1;
    _log_fn "## ! Unable to locate the UglifyJS Compressor.";
    _log_fn " # Try cd ${_npm_dir}; npm install uglifyjs@2.4.10 -D"
    _log_fn " # IMPORTANT! Be sure to patch this as described";
    _log_fn " # in the general help section!";
    _abort_fn;
  fi
  ## END Find UglifyJS

  ## BEGIN Find UglifyCSS
  if [ -z "${_ugcss_exe}" ]; then
    _do_verbose=1;
    _log_fn "## ! Unable to locate the UglifyCSS Compressor.";
    _log_fn " # Try cd ${_npm_dir}; npm install uglifycss -D"
    _abort_fn;
  fi
  ## END Find UglifyCSS

  ## BEGIN validiate input files
  _manifest_list=();
  for _manifest_file in $@; do
    if [ ! -f "${_manifest_file}" ]; then
      _do_verbose=1;
      _log_fn "## ! manifest file '${_manifest_file}' is not a regular file.";
      _abort_fn;
    fi

    if [ ! -r "${_manifest_file}" ]; then
      _do_verbose=1;
      _log_fn "## ! manifest file '${_manifest_file}' is not readable.";
      _abort_fn;
    fi

    _manifest_list[${#_manifest_list[*]}]="${_manifest_file}"
    _log_fn "  # Adding ${_manifest_file} to process list"
  done

  if [ "${#_manifest_list[*]}" = 0 ]; then
    _do_verbose=1;
    _log_fn "## ! No build file provided."
    _abort_fn;
  fi
  ## END validiate input files


  ## BEGIN process each buildfile in turn
  for (( _file_idx = 0; _file_idx < ${#_manifest_list[*]}; _file_idx++ )); do
    ## BEGIN get path of buildfile and determine output names
    _manifest_file="${_manifest_list[$_file_idx]}";
    _manifest_basename=$( basename "${_manifest_file}" );
    _manifest_short_name=$( echo "${_manifest_basename}" |cut -f1 -d'.' );
    _manifest_dir=$( dirname "${_manifest_file}" );
    _manifest_dir=$( cd "${_manifest_dir}" && echo "${PWD}" );

    if [ -z "${_manifest_short_name}" ]; then
      _do_verbose=1;
      _log_fn "## ! Root name of the build file is empty.  Please notify author.";
      _abort_fn;
    fi

    _log_fn "## Buildify for '${_manifest_file}' on ${_start_date_}";
    ## END get path of buildfile and determine output names

    ## BEGIN read build file and append sources to arrays
    _js_file_list=();
    _css_file_list=();
    _source_type='';

    while read _row_str; do
      # skip blank lines
      echo "${_row_str}" | grep -q '^\s*$' && continue;
      # skip full-line comments
      echo "${_row_str}" | grep -q '^\s*#' && continue;

      # strip end of line comments and indents
      _row_str=$(echo "${_row_str}" | sed -e 's/#.*$//g' \
        | sed -e 's/^\s\+//g' | sed -e 's/\s\+$//g' );

      # get directives for paths
      if echo "${_row_str}" | grep -q '^distdir\s*:'; then
        _dist_dir=$( echo "${_row_str}" |sed -e 's/distdir\s*:\s*//g' );
        _dist_dir="${_manifest_dir}/${_dist_dir}";
        continue;
      fi
      if echo "${_row_str}" | grep -q '^stagedir\s*:'; then
        _stage_dir=$( echo "${_row_str}" |sed -e 's/stagedir\s*:\s*//g' );
        _stage_dir="${_manifest_dir}/${_stage_dir}";
        continue;
      fi
      if echo "${_row_str}" | grep -q '^proddir\s*:'; then
        _prod_dir=$( echo "${_row_str}" |sed -e 's/proddir\s*:\s*//g' );
        _prod_dir="${_manifest_dir}/${_prod_dir}";
        continue;
      fi
      if echo "${_row_str}" | grep -q '^tmpltdir\s*:'; then
        _tmplt_dir=$( echo "${_row_str}" |sed -e 's/tmpltdir\s*:\s*//g' );
        _tmplt_dir="${_manifest_dir}/${_tmplt_dir}";
        continue;
      fi

      # process section headers
      if echo "${_row_str}" | grep -q '^sourcetype\s*:'; then
        _source_type=$( echo "${_row_str}" |sed -e 's/sourcetype\s*:\s*//g' );
        _log_fn "## SOURCE TYPE ${_source_type}";
        continue;
      fi

      # skip anything if section type not yet specified
      [ "${_source_type}" == '' ] && continue;

      # determine full path to source file and test
      _source_file="${_manifest_dir}/${_row_str}";

      if [ ! -r "${_source_file}" ]; then
        _do_verbose=1;
        _log_fn "${_source_type} file ${_source_file} is not readable.";
        _log_fn "Do you need to update your manifest file?";
        _log_fn "X_${_row_str}_X";
        _abort_fn;
      fi

      EXT=$( echo ${_row_str} |sed -e 's/^.*\.//' );

      case "${_source_type}" in
        js)
          if [ "${EXT}" != 'js' ]; then
            _do_verbose=1;
            _log_fn "# Extension for js file ${_row_str} must be 'js'";
            _abort_fn;
          fi

          _js_file_list[${#_js_file_list[*]}]=${_source_file};
            _log_fn "  # Added file ${_row_str} to javascript processing queue.";
          ;;

        css)
          if [ "${EXT}" != 'css' ]; then
            _do_verbose=1;
            _log_fn "# Extension for css file ${_row_str} must be 'css'";
            _abort_fn;
          fi

          _css_file_list[${#_css_file_list[*]}]=${_source_file};
          _log_fn "  # Added file ${_row_str} to css processing queue.";
          ;;
        *) _do_verbose=1;
          _log_fn "Source type (${_source_type}) not supported.";
          _abort_fn;
          ;;
      esac
    done < "${_manifest_file}"
    ## END read build file and append sources to arrays

    ## BEGIN validate stage dir and move global log there
    if [ "${_stage_dir}" == '' ]; then
      _stage_dir="${_manifest_dir}";
    else
      mkdir -p "${_stage_dir}";
    fi

    if [ ! -d "${_stage_dir}" ]; then
      _do_verbose=1;
      _log_fn "## ! Stage directory is not valid";
      _abort_fn;
    fi

    # normalize path (get rid of ../../ constructs)
    cd "${_stage_dir}";
    _stage_dir=$(pwd);

    if [ ! -w "${_stage_dir}" ]; then
      _do_verbose=1;
      _log_fn "## ! Stage directory is not writable";
      _abort_fn;
    fi

    if ! mv "${_top_log_file}" "${_stage_dir}"; then
      _do_verbose=1;
      _log_fn "## ! Could not move global log to stage directory";
      _abort_fn;
    else
      _top_log_file="${_stage_dir}/${_top_log_name}";
    fi
    ## END validate output dir if provided and move global log there

    _js_concat_file="${_tmp_dir}/$$.${_manifest_short_name}-src.js";
    _css_concat_file="${_tmp_dir}/$$.${_manifest_short_name}-src.css";

    STAGE_ROOT_NAME="${_stage_dir}/${_manifest_short_name}";

    _pack_log_file="${STAGE_ROOT_NAME}-sp.log";
    _pack_diag_file="${STAGE_ROOT_NAME}-sp.diag";
    _ugcss_log_file="${STAGE_ROOT_NAME}-ug_css.log";
    UGJS_LOG_FILE="${STAGE_ROOT_NAME}-ug_js.log";

    _css_out_file="${STAGE_ROOT_NAME}-raw.css";
    _js_out_file="${STAGE_ROOT_NAME}-raw.js";
    ugcss_out_file="${STAGE_ROOT_NAME}-min.css";
    _ugjs_out_file="${STAGE_ROOT_NAME}-min.js";
    _pack_out_file="${STAGE_ROOT_NAME}-sp.js";

    touch "${_pack_log_file}";

    if [ ! -w "${_stage_dir}" ]; then
      _do_verbose=1;
      _log_fn "## ! Stage directory is not writable";
      _abort_fn;
    fi

    ## BEGIN process javascript files
    for (( i = 0; i < ${#_js_file_list[*]}; i++ ))
    do
      if [ ! -r "${_js_concat_file}" ]; then
        touch "${_js_concat_file}";
        if [ ! -r "${_js_concat_file}" ]; then
          _do_verbose=1;
          _log_fn "Cannot create concatenation file '${_js_concat_file}'";
          _log_fn "for Javascript processing."
          _abort_fn;
        fi
        _log_fn '## Combining JS Source Files';
      fi
      cat "${_js_file_list[$i]}" >> "${_js_concat_file}";
      _log_fn "  # ${_js_file_list[$i]}";
    done
    ## END process javascript files

    ## BEGIN compress javascript file if specified
    if [ -r "${_js_concat_file}" ] && [ ${_dont_compress} -eq 0 ]; then
      _log_fn "## Uglify compressing '${_js_concat_file}'";

      ${_ugjs_exe} "${_js_concat_file}" -mc \
        1>  "${_ugjs_out_file}" \
        2>> "${UGJS_LOG_FILE}";
      UGJS_EXIT_STATUS=$?;

      if [ ${UGJS_EXIT_STATUS} == 0 ]; then
        _log_fn "  # Compression successful.  Output is '${_ugjs_out_file}'";
        rm "${UGJS_LOG_FILE}";
      else
        _do_verbose=1;
        _log_fn "  # ! Compression of '${_js_concat_file}' not successfull";
        _log_fn "  # ! See '${UGJS_LOG_FILE}' for errors";
        _abort_fn;
      fi
    fi
    ## END compress javascript file if specified

    ## BEGIN run superpack on this file if config found
    if [ -r "${_js_concat_file}" ] && [ ${_dont_compress} -eq 0 ]; then
      ${_pack_exe} \
        -i "${_ugjs_out_file}" \
        -o "${_pack_out_file}" \
        -l "${_pack_log_file}" \
        > ${_pack_diag_file} 2>&1
      _pack_exit_code=$?;

      if [ ${_pack_exit_code} == 0 ]; then
        _log_fn "  # SuperPack successful.  Output is '${_pack_out_file}'";
      else
        _do_verbose=1;
        _log_fn "  # ! SuperPack of '${_js_concat_file}' not successfull";
        _log_fn "  # ! See '${_pack_log_file}' for errors";
        _abort_fn;
      fi
    fi
    ## END run superpack on this file if config found

    ## BEGIN process css files
    for (( i = 0; i < ${#_css_file_list[*]}; i++ ))
    do
      if [ ! -r "${_css_concat_file}" ]; then
        touch "${_css_concat_file}";
        if [ ! -r "${_css_concat_file}" ]; then
          _do_verbose=1;
          _log_fn "## ! Cannot create concatenation file '${_css_concat_file}'";
          _log_fn "  #  for CSS processing.";
          _abort_fn;
        fi
        _log_fn '## Combining CSS Source Files';
        _log_fn "  # Writing css concat file '${_css_concat_file}'";
      fi
      cat "${_css_file_list[$i]}" >> "${_css_concat_file}";
      _log_fn "  # ${_css_file_list[$i]}";
    done
    ## END process css files

    ## BEGIN compress css file if specified
    if [ -r "${_css_concat_file}" ] && [ ${_dont_compress} -eq 0 ]; then
      _log_fn "## UglifyCSS Compressing '${_css_concat_file}'";
    
      ${_ugcss_exe} "${_css_concat_file}" \
        1> "${ugcss_out_file}" \
        2>> "${_ugcss_log_file}";
      _ugcss_exit_code=$?;
    
      if [ ${_ugcss_exit_code} == 0 ]; then
        _log_fn "  # Compression successful.  Output is '${ugcss_out_file}'";
        rm "${_ugcss_log_file}";
      else
        _do_verbose=1;
        _log_fn "  # ! Compression of '${_css_concat_file}' not successfull";
        _log_fn "  # ! See '${_ugcss_log_file}' for warnings";
        _abort_fn;
      fi
    fi
    ## END compress css file if specified

    ## BEGIN move over remaining files
    for _pair_str in \
      "${_js_concat_file}_XX_${_js_out_file}" \
      "${_css_concat_file}_XX_${_css_out_file}";
    do
      _pair_src_file=$(echo "${_pair_str}" |gawk -F'_XX_' '{print $1}');
      _pair_dst_file=$(echo "${_pair_str}" |gawk -F'_XX_' '{print $2}');

      if [ -r "${_pair_src_file}" ]; then
        if ! mv "${_pair_src_file}" "${_pair_dst_file}"; then
          _do_verbose=1;
          _log_fn "Could not move ${_pair_src_file} to ${_pair_dst_file}";
          _abort_fn;
        fi
      fi
    done
    ## END move over remaining files
  done
  ## END process each buildfile in turn

  ## mkdir -p "${_dist_dir}";
  ## cd "${_dist_dir}";
  ## _dist_dir=$(pwd);
  ##
  ## cd "${_prod_dir}";
  ## _prod_dir=$(pwd);
  ##
  ## cd "${_tmplt_dir}";
  ## _tmplt_dir=$(pwd);
  ##
  ## mkdir -p "${_dist_dir}/js";
  ## mkdir -p "${_dist_dir}/img";
  ## mkdir -p "${_dist_dir}/font/vendor";
  ## cp "${_stage_dir}/xhi-sp.js" "${_dist_dir}/js/"

  ## TODO Provide ability to copy media file to dist dist like so:
  ## media:
  ## cp "${_prod_dir}/img/xhi-bkgd-001.jpg" "${_dist_dir}/img/"

  ## REPLACE_CMD=$(
  ## node -e '
  ##   var fs = require( "fs" );
  ##   fs.readFile(
  ##     "../stage/xhi-sp.log",
  ##     "utf8",
  ##     function( error, json_str ) {
  ##       if ( error ) { return console.error( error ); }
  ##       log_map = JSON.parse( json_str );
  ##       console.log(
  ##         "xhi."
  ##         + log_map[ "_shell_" ]
  ##         + "."
  ##         + log_map[ "_initModule_" ]
  ##       );
  ##     }
  ##   );
  ## '
  ## );
  ## sed -e "s/REPLACE_CMD/${REPLACE_CMD}/g" \
  ## "${_tmplt_dir}/index.html.tmplt" > "${_dist_dir}/index.html"

  clean_tmp_files;
  _end_date=$(date "+%Y-%m-%d %H:%M:%S");
  _log_fn "## ${_app_name} run complete on ${_end_date} ##";
## END MAIN

