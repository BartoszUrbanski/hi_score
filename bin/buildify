#!/bin/bash

## These checks are disabled as they cause trouble
## set -e -u;
set -u;

## == BEGIN Layout variables ===============================================
  APP_NAME=$( basename $0 );
  echo "start ${APP_NAME}";
  echo "  > layout vars";

    APP_LINK=$( readlink -f -- "${0}" );
    ORIG_DIR=$( pwd );

    BIN_DIR=$( cd "${APP_LINK%/*}" && echo "${PWD}" );
    NPM_DIR=$( dirname "${BIN_DIR}" );

    # We must declare these for cli switches
    DIST_DIR='';
    STAGE_DIR='';
    PROD_DIR='';  
    TMPLT_DIR='';

    NPM_DIR=$( dirname "${BIN_DIR}" );
    MOD_DIR="${NPM_DIR}/node_modules";
    MOD_DIR_BIN="${MOD_DIR}/.bin";
    TMP_DIR="${TMPDIR-/tmp}";

    UGJS_EXE="${MOD_DIR_BIN}/uglifyjs";
    UGCSS_EXE="${MOD_DIR_BIN}/uglifycss";

    GLOBAL_LOG_NAME="${APP_NAME}.log";
    GLOBAL_LOG_FILE="${PWD}/${GLOBAL_LOG_NAME}";
    LOG_FILE='';

    HELP_SW=0;
    NOCOMPRESS_SW=0;
    VERBOSE_SW=0;

    TIMESTAMP_START=$(date "+%Y-%m-%d %H:%M:%S");
    TIMESTAMP_EXT=$(date "+%Y%m%d_%H%M%S");
  # echo "  < layout vars";
  ## == END Layout variables =================================================

## BEGIN function to echo to STDERR
echose () { echo "$*" >&2; }
## END function to echo to STDERR

## BEGIN function to print usage
usage () {
  echose "
NAME : ${APP_NAME}

SYNOPSIS
  ${APP_NAME} [ options ] <buildfile1> <buildfile2> ...
";

  [ "${VERBOSE_SW}" -lt 1 ] && echose "
Employ the -v or --verbose switch to see more detailed help.
";

  [ "${VERBOSE_SW}" -gt 0 ] && echose "
DESCRIPTION
  ${APP_NAME} builds production-ready JavaScript files
  from sources specified in buildfiles.

  If the build file includes a javascript section, it creates
  a two javascript files in the same directory as the build file.
  The output files will have the same basename as the buildfile.
  Therefore, '${APP_NAME} gallery.${APP_NAME}' will output
  the files gallery-raw.js, gallery-min.js, and gallery-sp.js.

  Options may be employed to change the output location, and to turn
  compression off.

EXAMPLES
  (1) If the file gallery.${APP_NAME} looks like so:
      ==============
      source:js
      js/gallery.js
      ==============

  Then running buildify with this configuration:

      $ ${APP_NAME} ./gallery.${APP_NAME}

  will result in the following files:

      gallery-raw.js  # concatenated JS
      gallery-min.js  # uglified JS
      gallery-sp.js   # superpacked JS
      gallery-sp.diag # superpack diagnostics


  (2) If the file gallery.${APP_NAME} looks like so:
      ==============
      source:js
      js/gallery.js
      source:css
      css/gallery.css
      ==============

  Then running buildify with this configuration:

      ${APP_NAME} --nocompress ./gallery.${APP_NAME}

  will result in the following files:

      gallery-raw.js   # concatenated JS
      gallery-raw.css  # concatenated CSS


  (3) We can specify an alternate output directory.
      If the file gallery.${APP_NAME} looks like so:
      ==============
      source:js
      js/gallery.js
      source:css
      css/gallery.css
      ==============

  Then running buildify with this configuration:

      ${APP_NAME} -o /stage ./gallery.${APP_NAME}

  will result in the following files in the directory /stage:

      gallery-raw.js  # concatenated JS
      gallery-min.js  # uglified JS
      gallery-sp.js   # superpacked JS
      gallery-sp.diag # superpack diagnostics
      gallery-raw.css # concatenated CSS
      gallery-raw.css # minified CSS

ARGUMENTS
  buildfile1, buildfile2, ... (REQUIRED)
    Build files to process.
    Each build file lists source files to process. It may have up to
    two sections delineated by a source-type header.
    ${APP_NAME} EXPECTS ALL PATHS TO BE RELATIVE TO THE REFERENCING 
    MANIFEST_FILE PATH.
       sourcetype:js   # for javascript files, and
       # ... js files here ...
       sourcetype:css # for css and source files
       # ... css files here .... (relative to buildfile path)

    Blank lines, comment lines, and trailing comments are ignored.

OPTIONS
  * -h | --help | --usage outputs this text and exit.

  * -o <path> |--outputdir=<path> (OPTIONAL)
    By default, ${APP_NAME} puts output files in the same directory
    as the build file.  Use this option to override the default location.
    <path> must be a writable directory.

  * -n | --nocompress (OPTIONAL)
    By default, ${APP_NAME} outputs minified named <name>-min.js
    and <name>-min.css.  This option disables creating and writing these
    files.

  * -v | --verbose (OPTIONAL)
    Be noisy when processing

REQUIRED PATCH
  Buildify requires a patch to optimize symbol compression. 
  If you have installed **hi\_score** this patch will already be applied.
  If you need to install the patch manually, this should work:
  
    \$ cd ../node_modules/
    \$ patch -p0 < ../patch/uglifyjs-2.4.10.patch

SEE ALSO
  * UglifyJS
  * UglifyCSS

AUTHOR and COPYRIGHT
  Michael S. Mikowski (c) 2008-2016
";

  exit 1;
}
## END function to print usage

## BEGIN function to log output
loggit () {
  local IFS='';
  LOG_STR="$*";
  if [ "${LOG_FILE}" != '' ]; then
    echo "${LOG_STR}" >> "${LOG_FILE}";
  elif [ "${GLOBAL_LOG_FILE}" != '' ]; then
    echo "${LOG_STR}" >> "${GLOBAL_LOG_FILE}";
  else
    echose "${LOG_STR}"
  fi

  if [ "${VERBOSE_SW}" -gt 0 ]; then echose "${LOG_STR}"; fi
  return 0;
}
## END function to log output

## BEGIN function to clean up temp files
clean_tmp_files () {
  LOG_FILE='';
  if [ -w "${TMP_DIR}" ]; then
    if echo "${TMP_DIR}" | grep -q "${APP_NAME}"; then
      VERBOSE_SW=1;
      loggit "## Removing temporary directory ${TMP_DIR}";
      rm -rf "${TMP_DIR}";
    fi
  fi
}
## END function to clean up temp files

## BEGIN function to abort processing
abort () {
  VERBOSE_SW=1;
  loggit '';
  loggit "## See ${APP_NAME} -hv for detailed usage.";
  loggit "## ! Processing ABORTED.";

  clean_tmp_files;
  # exit with error (bash shell standard)
  exit 1;
}
## END function to abort processing

## BEGIN MAIN
  ## BEGIN get app path and name
  ## END get app path and name

  ## BEGIN get options
  ## (see /usr/share/doc/util-linux/examples/getopt-parse.bash)
  TEMP=$(getopt -o hnvd:s:p:t: \
    --long help,usage,nocompress,verbose,distdir:,stagedir:,proddir:,tmpltdir: \
      -n "${APP_NAME}" -- "$@")

  if [ $? != 0 ] ; then
		VERBOSE_SW=1;
    echose "Trouble processing command line.";
    abort; 
  fi

  # Note the quotes around $TEMP: they are essential!
  eval set -- "${TEMP}"

  while true; do
    case "$1" in
      -h|--help|--usage) HELP_SW=1;       shift ;;
      -n|--nocompress)   NOCOMPRESS_SW=1; shift ;;
      -v|--verbose)      VERBOSE_SW=1;    shift ;;
      -d|--distdir)      DIST_DIR="$2";   shift 2 ;;
      -s|--stagedir)     STAGE_DIR="$2";  shift 2 ;;
      -p|--proddir)      PROD_DIR="$2";   shift 2 ;;
      -t|--tmpltdir)     TMPLT_DIR="$2";  shift 2 ;;
      --) shift; break ;;
       *) VERBOSE_SW=1;
          echose "Trouble processing command line.";
          abort ;;
    esac
  done

  if [ ${HELP_SW} -gt 0 ]; then usage; fi
  ## END get options (see /usr/share/doc/util-linux/examples/getopt-parse.bash)

  ## BEGIN set global log to start
  if ! echo -n > "${GLOBAL_LOG_FILE}"; then
    VERBOSE_SW=1;
    echose "Cannot create global log file '${GLOBAL_LOG_FILE}'";
    abort;
  fi
  # put header in log file
  loggit "## Global ${APP_NAME} log ${TIMESTAMP_START} ##";
  ## END set global log to start

  ## BEGIN set up temporary storage area
  ## See http://www.linuxsecurity.com/content/view/115462/81/#mozTocId440182
  TMP_DIR="${TMP_DIR}/$$.${APP_NAME}.${TIMESTAMP_EXT}";
  ( umask 077 && mkdir "${TMP_DIR}" ) || {
    VERBOSE_SW=1;
    loggit "## ! Could not create temporary directory";
    abort;
  }
  ## END set up temporary storage area

  ## BEGIN Find SuperPack
  SP_EXE="${BIN_DIR}/superpack.pl";
  if [ -z "${SP_EXE}" ]; then
    VERBOSE_SW=1;
    loggit "## ! Unable to locate the SuperPack compressor.";
    loggit " # See Michael Mikowski for original executable.";
    abort;
  fi
  if ( ! perl -cw "${SP_EXE}" >/dev/null 2>&1 ); then
    VERBOSE_SW=1;
    loggit "## ! SuperPack is not valid perl.";
    loggit " # Please install perl-List-MoreUtils perl-File-Slurp ";
    loggit " # and perl-Getopt-Mixed.";
    abort;
  fi
  ## END Find SUPERPACK

  ## BEGIN Find UglifyJS
  if [ -z "${UGJS_EXE}" ]; then
    VERBOSE_SW=1;
    loggit "## ! Unable to locate the UglifyJS Compressor.";
    loggit " # Try cd ${NPM_DIR}; npm install uglifyjs@2.4 -D"
    loggit " # IMPORTANT! Be sure to patch this as described";
    loggit " # in the general help section!";
    abort;
  fi
  ## END Find UglifyJS

  ## BEGIN Find UglifyCSS
  if [ -z "${UGCSS_EXE}" ]; then
    VERBOSE_SW=1;
    loggit "## ! Unable to locate the UglifyCSS Compressor.";
    loggit " # Try cd ${NPM_DIR}; npm install uglifycss -D"
    abort;
  fi
  ## END Find UglifyCSS

  ## BEGIN validiate input files
  MANIFEST_LIST=();
  for MANIFEST_FILE in $@; do
    if [ ! -f "${MANIFEST_FILE}" ]; then
      VERBOSE_SW=1;
      loggit "## ! manifest file '${MANIFEST_FILE}' is not a regular file.";
      abort;
    fi

    if [ ! -r "${MANIFEST_FILE}" ]; then
      VERBOSE_SW=1;
      loggit "## ! manifest file '${MANIFEST_FILE}' is not readable.";
      abort;
    fi

    MANIFEST_LIST[${#MANIFEST_LIST[*]}]="${MANIFEST_FILE}"
    loggit "  # Adding ${MANIFEST_FILE} to process list"
  done

  if [ "${#MANIFEST_LIST[*]}" = 0 ]; then
    VERBOSE_SW=1;
    loggit "## ! No build file provided."
    abort;
  fi
  ## END validiate input files


  ## BEGIN process each buildfile in turn
  for (( MANIFEST_IDX = 0; MANIFEST_IDX < ${#MANIFEST_LIST[*]}; MANIFEST_IDX++ )); do
    ## BEGIN get path of buildfile and determine output names
    MANIFEST_FILE="${MANIFEST_LIST[$MANIFEST_IDX]}";
    MANIFEST_BASENAME=$( basename "${MANIFEST_FILE}" );
    MANIFEST_SHORTNAME=$( echo "${MANIFEST_BASENAME}" |cut -f1 -d'.' );
    MANIFEST_DIR=$( dirname "${MANIFEST_FILE}" );
    MANIFEST_DIR=$( cd "${MANIFEST_DIR}" && echo "${PWD}" );

    if [ -z "${MANIFEST_SHORTNAME}" ]; then
      VERBOSE_SW=1;
      loggit "## ! Root name of the build file is empty.  Please notify author.";
      abort;
    fi

    loggit "## Buildify for '${MANIFEST_FILE}' on ${TIMESTAMP_START}";
    ## END get path of buildfile and determine output names

    ## BEGIN read build file and append sources to arrays
    ARY_JS_FILES=();
    ARY_CSS_FILES=();
    SW_SOURCE_TYPE='';

    while read LINE; do
      # skip blank lines
      echo "${LINE}" | grep -q '^\s*$' && continue;
      # skip full-line comments
      echo "${LINE}" | grep -q '^\s*#' && continue;

      # strip end of line comments and indents
      LINE=$(echo "${LINE}" | sed -e 's/#.*$//g' \
        | sed -e 's/^\s\+//g' | sed -e 's/\s\+$//g' );

      # get directives for paths
      if echo "${LINE}" | grep -q '^distdir\s*:'; then
        DIST_DIR=$( echo "${LINE}" |sed -e 's/distdir\s*:\s*//g' );
        DIST_DIR="${MANIFEST_DIR}/${DIST_DIR}";
        continue;
      fi
      if echo "${LINE}" | grep -q '^stagedir\s*:'; then
        STAGE_DIR=$( echo "${LINE}" |sed -e 's/stagedir\s*:\s*//g' );
        STAGE_DIR="${MANIFEST_DIR}/${STAGE_DIR}";
        continue;
      fi
      if echo "${LINE}" | grep -q '^proddir\s*:'; then
        PROD_DIR=$( echo "${LINE}" |sed -e 's/proddir\s*:\s*//g' );
        PROD_DIR="${MANIFEST_DIR}/${PROD_DIR}";
        continue;
      fi
      if echo "${LINE}" | grep -q '^tmpltdir\s*:'; then
        TMPLT_DIR=$( echo "${LINE}" |sed -e 's/tmpltdir\s*:\s*//g' );
        TMPLT_DIR="${MANIFEST_DIR}/${TMPLT_DIR}";
        continue;
      fi

      # process section headers
      if echo "${LINE}" | grep -q '^sourcetype\s*:'; then
        SW_SOURCE_TYPE=$( echo "${LINE}" |sed -e 's/sourcetype\s*:\s*//g' );
        loggit "## SOURCE TYPE ${SW_SOURCE_TYPE}";
        continue;
      fi

      # skip anything if section type not yet specified
      [ "${SW_SOURCE_TYPE}" == '' ] && continue;

      # determine full path to source file and test
      SRC_FILE="${MANIFEST_DIR}/${LINE}";

      if [ ! -r "${SRC_FILE}" ]; then
        VERBOSE_SW=1;
        loggit "${SW_SOURCE_TYPE} file ${SRC_FILE} is not readable.";
        loggit "Do you need to update your manifest file?";
        loggit "X_${LINE}_X";
        abort;
      fi

      EXT=$( echo ${LINE} |sed -e 's/^.*\.//' );

      case "${SW_SOURCE_TYPE}" in
        js)
          if [ "${EXT}" != 'js' ]; then
            VERBOSE_SW=1;
            loggit "# Extension for js file ${LINE} must be 'js'";
            abort;
          fi

          ARY_JS_FILES[${#ARY_JS_FILES[*]}]=${SRC_FILE};
            loggit "  # Added file ${LINE} to javascript processing queue.";
          ;;

        css)
          if [ "${EXT}" != 'css' ]; then
            VERBOSE_SW=1;
            loggit "# Extension for css file ${LINE} must be 'css'";
            abort;
          fi

          ARY_CSS_FILES[${#ARY_CSS_FILES[*]}]=${SRC_FILE};
          loggit "  # Added file ${LINE} to css processing queue.";
          ;;
        *) VERBOSE_SW=1;
          loggit "Source type (${SW_SOURCE_TYPE}) not supported.";
          abort;
          ;;
      esac
    done < "${MANIFEST_FILE}"
    ## END read build file and append sources to arrays

    ## BEGIN validate stage dir and move global log there
    if [ "${STAGE_DIR}" == '' ]; then
      STAGE_DIR="${MANIFEST_DIR}";
    else
      mkdir -p "${STAGE_DIR}";
    fi

    if [ ! -d "${STAGE_DIR}" ]; then
      VERBOSE_SW=1;
      loggit "## ! Stage directory is not valid";
      abort;
    fi

    # normalize path (get rid of ../../ constructs)
    cd "${STAGE_DIR}";
    STAGE_DIR=$(pwd);

    if [ ! -w "${STAGE_DIR}" ]; then
      VERBOSE_SW=1;
      loggit "## ! Stage directory is not writable";
      abort;
    fi

    if ! mv "${GLOBAL_LOG_FILE}" "${STAGE_DIR}"; then
      VERBOSE_SW=1;
      loggit "## ! Could not move global log to stage directory";
      abort;
    else
      GLOBAL_LOG_FILE="${STAGE_DIR}/${GLOBAL_LOG_NAME}";
    fi
    ## END validate output dir if provided and move global log there

    CONCAT_JS_FILE="${TMP_DIR}/$$.${MANIFEST_SHORTNAME}-src.js";
    CONCAT_CSS_FILE="${TMP_DIR}/$$.${MANIFEST_SHORTNAME}-src.css";

    STAGE_ROOT_NAME="${STAGE_DIR}/${MANIFEST_SHORTNAME}";
    UGJS_LOG_FILE="${STAGE_ROOT_NAME}-ug_js.log";
    SP_LOG_FILE="${STAGE_ROOT_NAME}-sp.log";
    SP_DIAG_FILE="${STAGE_ROOT_NAME}-sp.diag";
    UGCSS_LOG_FILE="${STAGE_ROOT_NAME}-ug_css.log";

    JS_OUT_FILE="${STAGE_ROOT_NAME}-raw.js";
    CSS_OUT_FILE="${STAGE_ROOT_NAME}-raw.css";
    MIN_JS_OUT_FILE="${STAGE_ROOT_NAME}-min.js";
    SUPERPACK_OUT_FILE="${STAGE_ROOT_NAME}-sp.js";
    MIN_CSS_OUT_FILE="${STAGE_ROOT_NAME}-min.css";

    LOG_FILE="${STAGE_ROOT_NAME}-raw.log";
    if !  echo -n > "${LOG_FILE}"; then
      VERBOSE_SW=1;
      LOG_FILE='';
      loggit "## ! Cannot create log file, '${LOG_FILE}'";
      abort;
    fi

    ## BEGIN process javascript files
    for (( i = 0; i < ${#ARY_JS_FILES[*]}; i++ ))
    do
      if [ ! -r "${CONCAT_JS_FILE}" ]; then
        touch "${CONCAT_JS_FILE}";
        if [ ! -r "${CONCAT_JS_FILE}" ]; then
          VERBOSE_SW=1;
          loggit "Cannot create concatenation file '${CONCAT_JS_FILE}'";
          loggit "for Javascript processing."
          abort;
        fi
        loggit '## Combining JS Source Files';
      fi
      cat "${ARY_JS_FILES[$i]}" >> "${CONCAT_JS_FILE}";
      loggit "  # ${ARY_JS_FILES[$i]}";
    done
    ## END process javascript files

    ## BEGIN compress javascript file if specified
    if [ -r "${CONCAT_JS_FILE}" ] && [ ${NOCOMPRESS_SW} -eq 0 ]; then
      loggit "## Uglify compressing '${CONCAT_JS_FILE}'";

      ${UGJS_EXE} "${CONCAT_JS_FILE}" -mc \
        1>  "${MIN_JS_OUT_FILE}" \
        2>> "${UGJS_LOG_FILE}";
      UGJS_EXIT_STATUS=$?;

      if [ ${UGJS_EXIT_STATUS} == 0 ]; then
        loggit "  # Compression successful.  Output is '${MIN_JS_OUT_FILE}'";
        rm "${UGJS_LOG_FILE}";
      else
        VERBOSE_SW=1;
        loggit "  # ! Compression of '${CONCAT_JS_FILE}' not successfull";
        loggit "  # ! See '${UGJS_LOG_FILE}' for errors";
        abort;
      fi
    fi
    ## END compress javascript file if specified

    ## BEGIN run superpack on this file if config found
    if [ -r "${CONCAT_JS_FILE}" ] && [ ${NOCOMPRESS_SW} -eq 0 ]; then
      ${SP_EXE} \
        -i "${MIN_JS_OUT_FILE}" \
        -o "${SUPERPACK_OUT_FILE}" \
        -l "${SP_LOG_FILE}" \
        > ${SP_DIAG_FILE} 2>&1

      SP_EXIT_STATUS=$?;

      if [ ${SP_EXIT_STATUS} == 0 ]; then
        loggit "  # SuperPack successful.  Output is '${SUPERPACK_OUT_FILE}'";
        # rm "${SP_LOG_FILE}";
      else
        VERBOSE_SW=1;
        loggit "  # ! SuperPack of '${CONCAT_JS_FILE}' not successfull";
        loggit "  # ! See '${SP_LOG_FILE}' for errors";
        abort;
      fi
    fi
    ## END run superpack on this file if config found

    ## BEGIN process css files
    for (( i = 0; i < ${#ARY_CSS_FILES[*]}; i++ ))
    do
      if [ ! -r "${CONCAT_CSS_FILE}" ]; then
        touch "${CONCAT_CSS_FILE}";
        if [ ! -r "${CONCAT_CSS_FILE}" ]; then
          VERBOSE_SW=1;
          loggit "## ! Cannot create concatenation file '${CONCAT_CSS_FILE}'";
          loggit "  #  for CSS processing.";
          abort;
        fi
        loggit '## Combining CSS Source Files';
        loggit "  # Writing css concat file '${CONCAT_CSS_FILE}'";
      fi
      cat "${ARY_CSS_FILES[$i]}" >> "${CONCAT_CSS_FILE}";
      loggit "  # ${ARY_CSS_FILES[$i]}";
    done
    ## END process css files

    ## BEGIN compress css file if specified
    if [ -r "${CONCAT_CSS_FILE}" ] && [ ${NOCOMPRESS_SW} -eq 0 ]; then
      loggit "## UglifyCSS Compressing '${CONCAT_CSS_FILE}'";
    
      ${UGCSS_EXE} "${CONCAT_CSS_FILE}" \
        1> "${MIN_CSS_OUT_FILE}" \
        2>> "${UGCSS_LOG_FILE}";
      UGCSS_EXIT_STATUS=$?;
    
      if [ ${UGCSS_EXIT_STATUS} == 0 ]; then
        loggit "  # Compression successful.  Output is '${MIN_CSS_OUT_FILE}'";
        rm "${UGCSS_LOG_FILE}";
      else
        VERBOSE_SW=1;
        loggit "  # ! Compression of '${CONCAT_CSS_FILE}' not successfull";
        loggit "  # ! See '${UGCSS_LOG_FILE}' for warnings";
        abort;
      fi
    fi
    ## END compress css file if specified

    # revert to global log
    LOG_FILE='';

    ## BEGIN move over remaining files
    for PAIR in \
      "${CONCAT_JS_FILE}_XX_${JS_OUT_FILE}" \
      "${CONCAT_CSS_FILE}_XX_${CSS_OUT_FILE}";
    do
      SRC=$(echo "${PAIR}" |gawk -F'_XX_' '{print $1}');
      DST=$(echo "${PAIR}" |gawk -F'_XX_' '{print $2}');

      if [ -r "${SRC}" ]; then
        if ! mv "${SRC}" "${DST}"; then
          VERBOSE_SW=1;
          loggit "Could not move ${SRC} to ${DST}";
          abort;
        fi
      fi
    done
    ## END move over remaining files
  done
  ## END process each buildfile in turn

  mkdir -p "${DIST_DIR}";
  cd "${DIST_DIR}";
  DIST_DIR=$(pwd);

  cd "${PROD_DIR}";
  PROD_DIR=$(pwd);

  cd "${TMPLT_DIR}";
  TMPLT_DIR=$(pwd);

  mkdir -p "${DIST_DIR}/js";
  mkdir -p "${DIST_DIR}/img";
  mkdir -p "${DIST_DIR}/font/vendor";
  cp "${STAGE_DIR}/xhi-sp.js" "${DIST_DIR}/js/"

  ## TODO Provide ability to copy media file to dist dist like so:
  ## media:
  ## cp "${PROD_DIR}/img/xhi-bkgd-001.jpg" "${DIST_DIR}/img/"

  REPLACE_CMD=$(
  node -e '
    var fs = require( "fs" );
    fs.readFile(
      "../stage/xhi-sp.log",
      "utf8",
      function( error, json_str ) {
        if ( error ) { return console.error( error ); }
        log_map = JSON.parse( json_str );
        console.log(
          "xhi."
          + log_map[ "_shell_" ]
          + "."
          + log_map[ "_initModule_" ]
        );
      }
    );
  '
  );
  sed -e "s/REPLACE_CMD/${REPLACE_CMD}/g" \
  "${TMPLT_DIR}/index.html.tmplt" > "${DIST_DIR}/index.html"

  clean_tmp_files;
  TIMESTAMP_END=$(date "+%Y-%m-%d %H:%M:%S");
  loggit "## ${APP_NAME} run complete on $TIMESTAMP_END ##";
## END MAIN

